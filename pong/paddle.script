go.property("ai", false)
go.property("speed", vmath.vector3(120, 0, 0))

-- cache input actions in local variables
-- it doesn't really have any major impact on performance for
-- a small game such as this if hash() would be called every
-- time on_input is invoked but it's good to make a habit of it
-- anyway
local LEFT = hash("left")
local RIGHT = hash("right")

local WALL = hash("wall")
local CONTACT_POINT_RESPONSE = hash("contact_point_response")

function init(self)
	-- acquire input if this paddle isn't controlled by the AI
	if not self.ai then
		msg.post(".", "acquire_input_focus")
		collectgarbage('setpause', 100)
	end
	
	-- pressed/released state of input actions
	self.actions = {}

	self.position = go.get_position()
end

function update(self, dt)
	-- if this is an AI controlled paddle we need to simulate a reasonably
	-- skilled opponent
	if self.ai then
		local ball_pos = go.get_position("ball")
		local ball_direction = go.get("ball#script", "direction")
		local my_pos = self.position

		-- only move the ai paddle when the ball is travelling towards the paddle
		if (ball_pos.y < my_pos.y and ball_direction.y > 0) then
			local horizontal_distance_to_ball = (my_pos.x - ball_pos.x)
			-- update direction of movement when the horizontal distance to the ball
			-- is above a threshold
			-- reduce this value to make the AI react faster
			if math.abs(horizontal_distance_to_ball) > 16 then
				self.actions[RIGHT] = horizontal_distance_to_ball < 0
				self.actions[LEFT] = horizontal_distance_to_ball > 0
			end
		else
			self.actions[LEFT] = nil
			self.actions[RIGHT] = nil
		end
	end
	-- move the paddle based on player/AI input
	if self.actions[RIGHT] then
		self.position = self.position + self.speed * dt
		go.set_position(self.position)
	elseif self.actions[LEFT] then
		self.position = self.position - self.speed * dt
		go.set_position(self.position)
	end
end

function on_message(self, message_id, message, sender)
	-- stop the paddle from going through the walls
	if message_id == CONTACT_POINT_RESPONSE and message.group == WALL then
		self.position = self.position + message.normal * message.distance
		go.set_position(self.position)
	end
end

function on_input(self, action_id, action)
	if action then
		-- store pressed/released state in action map
		-- we check these values in update() to move the
		-- paddle every frame
		if action.pressed then
			self.actions[action_id] = true
		elseif action.released then
			self.actions[action_id] = false
		end
	end
end

function on_reload(self)
	-- Add reload-handling code here
	-- Remove this function if not needed
end
